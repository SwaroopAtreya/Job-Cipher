{
  "version": 3,
  "sources": ["../../@aws-sdk/util-dynamodb/dist-es/NumberValue.js", "../../@aws-sdk/util-dynamodb/dist-es/convertToAttr.js", "../../@aws-sdk/util-dynamodb/dist-es/convertToNative.js", "../../@aws-sdk/util-dynamodb/dist-es/marshall.js", "../../@aws-sdk/util-dynamodb/dist-es/unmarshall.js"],
  "sourcesContent": ["export class NumberValue {\n    value;\n    constructor(value) {\n        if (typeof value === \"object\" && \"N\" in value) {\n            this.value = String(value.N);\n        }\n        else {\n            this.value = String(value);\n        }\n        const valueOf = typeof value.valueOf() === \"number\" ? value.valueOf() : 0;\n        const imprecise = valueOf > Number.MAX_SAFE_INTEGER ||\n            valueOf < Number.MIN_SAFE_INTEGER ||\n            Math.abs(valueOf) === Infinity ||\n            Number.isNaN(valueOf);\n        if (imprecise) {\n            throw new Error(`NumberValue should not be initialized with an imprecise number=${valueOf}. Use a string instead.`);\n        }\n    }\n    static from(value) {\n        return new NumberValue(value);\n    }\n    toAttributeValue() {\n        return {\n            N: this.toString(),\n        };\n    }\n    toBigInt() {\n        const stringValue = this.toString();\n        return BigInt(stringValue);\n    }\n    toString() {\n        return String(this.value);\n    }\n    valueOf() {\n        return this.toString();\n    }\n}\n", "import { NumberValue } from \"./NumberValue\";\nexport const convertToAttr = (data, options) => {\n    if (data === undefined) {\n        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n    }\n    else if (data === null && typeof data === \"object\") {\n        return convertToNullAttr();\n    }\n    else if (Array.isArray(data)) {\n        return convertToListAttr(data, options);\n    }\n    else if (data?.constructor?.name === \"Set\") {\n        return convertToSetAttr(data, options);\n    }\n    else if (data?.constructor?.name === \"Map\") {\n        return convertToMapAttrFromIterable(data, options);\n    }\n    else if (data?.constructor?.name === \"Object\" ||\n        (!data.constructor && typeof data === \"object\")) {\n        return convertToMapAttrFromEnumerableProps(data, options);\n    }\n    else if (isBinary(data)) {\n        if (data.length === 0 && options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        return convertToBinaryAttr(data);\n    }\n    else if (typeof data === \"boolean\" || data?.constructor?.name === \"Boolean\") {\n        return { BOOL: data.valueOf() };\n    }\n    else if (typeof data === \"number\" || data?.constructor?.name === \"Number\") {\n        return convertToNumberAttr(data, options);\n    }\n    else if (data instanceof NumberValue) {\n        return data.toAttributeValue();\n    }\n    else if (typeof data === \"bigint\") {\n        return convertToBigIntAttr(data);\n    }\n    else if (typeof data === \"string\" || data?.constructor?.name === \"String\") {\n        if (data.length === 0 && options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        return convertToStringAttr(data);\n    }\n    else if (options?.convertClassInstanceToMap && typeof data === \"object\") {\n        return convertToMapAttrFromEnumerableProps(data, options);\n    }\n    throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);\n};\nconst convertToListAttr = (data, options) => ({\n    L: data\n        .filter((item) => typeof item !== \"function\" &&\n        (!options?.removeUndefinedValues || (options?.removeUndefinedValues && item !== undefined)))\n        .map((item) => convertToAttr(item, options)),\n});\nconst convertToSetAttr = (set, options) => {\n    const setToOperate = options?.removeUndefinedValues ? new Set([...set].filter((value) => value !== undefined)) : set;\n    if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {\n        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n    }\n    if (setToOperate.size === 0) {\n        if (options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);\n    }\n    const item = setToOperate.values().next().value;\n    if (item instanceof NumberValue) {\n        return {\n            NS: Array.from(setToOperate).map((_) => _.toString()),\n        };\n    }\n    else if (typeof item === \"number\") {\n        return {\n            NS: Array.from(setToOperate)\n                .map((num) => convertToNumberAttr(num, options))\n                .map((item) => item.N),\n        };\n    }\n    else if (typeof item === \"bigint\") {\n        return {\n            NS: Array.from(setToOperate)\n                .map(convertToBigIntAttr)\n                .map((item) => item.N),\n        };\n    }\n    else if (typeof item === \"string\") {\n        return {\n            SS: Array.from(setToOperate)\n                .map(convertToStringAttr)\n                .map((item) => item.S),\n        };\n    }\n    else if (isBinary(item)) {\n        return {\n            BS: Array.from(setToOperate)\n                .map(convertToBinaryAttr)\n                .map((item) => item.B),\n        };\n    }\n    else {\n        throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);\n    }\n};\nconst convertToMapAttrFromIterable = (data, options) => ({\n    M: ((data) => {\n        const map = {};\n        for (const [key, value] of data) {\n            if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n                map[key] = convertToAttr(value, options);\n            }\n        }\n        return map;\n    })(data),\n});\nconst convertToMapAttrFromEnumerableProps = (data, options) => ({\n    M: ((data) => {\n        const map = {};\n        for (const key in data) {\n            const value = data[key];\n            if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n                map[key] = convertToAttr(value, options);\n            }\n        }\n        return map;\n    })(data),\n});\nconst convertToNullAttr = () => ({ NULL: true });\nconst convertToBinaryAttr = (data) => ({ B: data });\nconst convertToStringAttr = (data) => ({ S: data.toString() });\nconst convertToBigIntAttr = (data) => ({ N: data.toString() });\nconst validateBigIntAndThrow = (errorPrefix) => {\n    throw new Error(`${errorPrefix} Use NumberValue from @aws-sdk/lib-dynamodb.`);\n};\nconst convertToNumberAttr = (num, options) => {\n    if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]\n        .map((val) => val.toString())\n        .includes(num.toString())) {\n        throw new Error(`Special numeric value ${num.toString()} is not allowed`);\n    }\n    else if (!options?.allowImpreciseNumbers) {\n        if (Number(num) > Number.MAX_SAFE_INTEGER) {\n            validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);\n        }\n        else if (Number(num) < Number.MIN_SAFE_INTEGER) {\n            validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);\n        }\n    }\n    return { N: num.toString() };\n};\nconst isBinary = (data) => {\n    const binaryTypes = [\n        \"ArrayBuffer\",\n        \"Blob\",\n        \"Buffer\",\n        \"DataView\",\n        \"File\",\n        \"Int8Array\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"Int16Array\",\n        \"Uint16Array\",\n        \"Int32Array\",\n        \"Uint32Array\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n    ];\n    if (data?.constructor) {\n        return binaryTypes.includes(data.constructor.name);\n    }\n    return false;\n};\n", "import { NumberValue } from \"./NumberValue\";\nexport const convertToNative = (data, options) => {\n    for (const [key, value] of Object.entries(data)) {\n        if (value !== undefined) {\n            switch (key) {\n                case \"NULL\":\n                    return null;\n                case \"BOOL\":\n                    return Boolean(value);\n                case \"N\":\n                    return convertNumber(value, options);\n                case \"B\":\n                    return convertBinary(value);\n                case \"S\":\n                    return convertString(value);\n                case \"L\":\n                    return convertList(value, options);\n                case \"M\":\n                    return convertMap(value, options);\n                case \"NS\":\n                    return new Set(value.map((item) => convertNumber(item, options)));\n                case \"BS\":\n                    return new Set(value.map(convertBinary));\n                case \"SS\":\n                    return new Set(value.map(convertString));\n                default:\n                    throw new Error(`Unsupported type passed: ${key}`);\n            }\n        }\n    }\n    throw new Error(`No value defined: ${JSON.stringify(data)}`);\n};\nconst convertNumber = (numString, options) => {\n    if (typeof options?.wrapNumbers === \"function\") {\n        return options?.wrapNumbers(numString);\n    }\n    if (options?.wrapNumbers) {\n        return NumberValue.from(numString);\n    }\n    const num = Number(numString);\n    const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    const isLargeFiniteNumber = (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num);\n    if (isLargeFiniteNumber) {\n        if (typeof BigInt === \"function\") {\n            try {\n                return BigInt(numString);\n            }\n            catch (error) {\n                throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);\n            }\n        }\n        else {\n            throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);\n        }\n    }\n    return num;\n};\nconst convertString = (stringValue) => stringValue;\nconst convertBinary = (binaryValue) => binaryValue;\nconst convertList = (list, options) => list.map((item) => convertToNative(item, options));\nconst convertMap = (map, options) => Object.entries(map).reduce((acc, [key, value]) => ((acc[key] = convertToNative(value, options)), acc), {});\n", "import { convertToAttr } from \"./convertToAttr\";\nexport function marshall(data, options) {\n    const attributeValue = convertToAttr(data, options);\n    const [key, value] = Object.entries(attributeValue)[0];\n    switch (key) {\n        case \"M\":\n        case \"L\":\n            return options?.convertTopLevelContainer ? attributeValue : value;\n        case \"SS\":\n        case \"NS\":\n        case \"BS\":\n        case \"S\":\n        case \"N\":\n        case \"B\":\n        case \"NULL\":\n        case \"BOOL\":\n        case \"$unknown\":\n        default:\n            return attributeValue;\n    }\n}\n", "import { convertToNative } from \"./convertToNative\";\nexport const unmarshall = (data, options) => {\n    if (options?.convertWithoutMapWrapper) {\n        return convertToNative(data, options);\n    }\n    return convertToNative({ M: data }, options);\n};\n"],
  "mappings": "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",
  "names": ["item", "data"]
}
